# Match Retrieval Process

## Overview

The match retrieval system provides personalized profile recommendations to users based on pre-computed compatibility scores. The system uses a two-phase approach:

1. **Background Job**: Generates and stores match scores for all user pairs
2. **API Endpoint**: Retrieves and serves recommendations based on stored scores

---

## Architecture

### Components

- **`matchScoreJob`**: Background job that computes compatibility scores
- **`/api/profiles/recommendations`**: API endpoint that serves recommendations
- **`MatchScore` table**: Database table storing pre-computed scores
- **`loadRecentMatchScores`**: Loader function that queries match scores

---

## Phase 1: Match Score Generation (Background Job)

### Location
`backend/src/jobs/matchScoreJob.ts`

### Purpose
The `matchScoreJob` computes compatibility scores between users and stores them in the `MatchScore` table. This job should run periodically (e.g., daily or hourly) to keep scores fresh.

### How It Works

1. **Batch Processing**: Processes users in batches to avoid overwhelming the database
2. **Score Calculation**: Computes compatibility scores based on multiple factors:
   - **Quiz Compatibility** (`scoreQuiz`): Based on quiz answers and trait matching
   - **Interests** (`scoreInterests`): Shared interests and subjects
   - **Rating Quality** (`scoreRatingsQuality`): Average ratings received
   - **Rating Fit** (`scoreRatingsFit`): How well ratings align with preferences
   - **Newness** (`scoreNew`): Recency bonus for new profiles
   - **Proximity** (`scoreNearby`): Geographic distance factor

3. **Weighted Combination**: Scores are combined using configurable weights:
   ```typescript
   weights: {
     quiz: number;
     interests: number;
     ratingQuality: number;
     ratingFit: number;
     newness: number;
     proximity: number;
   }
   ```

4. **Storage**: Stores results in `MatchScore` table with:
   - `userId`: The user requesting recommendations
   - `candidateUserId`: The candidate being scored
   - `score`: Overall compatibility score (0-100+)
   - `scoredAt`: Timestamp when score was computed
   - Component scores and metadata

### Running the Job

The job can be run for:
- **All users**: Processes all users in the system
- **Specific user**: Processes scores for a single user
- **Batch mode**: Processes users in configurable batch sizes

### Configuration

Key configuration options:
- `userBatchSize`: Number of users to process at once
- `candidateBatchSize`: Number of candidates to score per user
- `algorithmVersion`: Version identifier for the scoring algorithm
- `topK`: Number of top scores to keep per user (default: 200)
- `minTraitOverlap`: Minimum trait overlap required (default: 2)
- `minRatingCount`: Minimum rating count required (default: 3)

---

## Phase 2: Recommendations Retrieval (API)

### Location
`backend/src/registry/domains/profiles/handlers/recommendations.ts`

### Endpoint
`GET /api/profiles/recommendations`

### Authentication
Requires authenticated user (returns 401 if not authenticated)

### Request Parameters
- `limit` (optional): Number of recommendations to return (default: 20, max: 50)
- `cursor` (optional): Base64-encoded pagination cursor
- `radiusKm` (optional): Maximum distance in kilometers (requires viewer location in profile)
  - When set: Only returns profiles within the specified radius
  - Excludes profiles with null `distanceKm` (no location data)
  - Requires viewer's profile to have `lat` and `lng` set
  - Example: `radiusKm=50` returns profiles within 50 km

### How It Works

#### Step 1: Authentication & Validation
```typescript
// Ensure user is authenticated
if (!req.ctx?.userId) {
  return json(res, { error: 'Authentication required' }, 401);
}

// Validate userId
const viewerId = req.ctx.userId;
```

#### Step 2: Load Recent Match Scores
```typescript
// Use 7-day window to ensure we have recommendations
// even if the match score job hasn't run recently
const sevenDaysAgo = new Date();
sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);

const scored = await loadRecentMatchScores(viewerId, {
  limit: take,
  cursorUserId,
  cursorScore,
  minAge: sevenDaysAgo  // Only scores from last 7 days
});
```

**Query Logic** (`loadRecentMatchScores`):
- Filters by `userId` (the requesting user)
- Filters by `scoredAt >= sevenDaysAgo` (freshness requirement)
- Orders by `score DESC, candidateUserId DESC` (best matches first)
- Supports pagination via cursor (score + userId)

#### Step 3: Handle Empty Results

If no match scores are found within the 7-day window:

```typescript
if (scoreRows.length === 0) {
  console.log('[recommendations] No match scores found', {
    viewerId: viewerId.toString(),
    sevenDaysAgo: sevenDaysAgo.toISOString(),
    note: 'Match scores may need to be generated by the matchScoreJob'
  });
  return json(res, {
    profiles: [],
    nextCursor: null
  });
}
```

**Current Behavior**: Returns empty array if no recent scores exist.

**Potential Fallback** (not currently implemented):
- Expand time window (e.g., 30 days, then unlimited)
- Remove time restriction entirely
- Return lower-quality matches with a flag indicating they're stale

#### Step 4: Filter Candidates

```typescript
// Filter out blocked users and self
const blockedUserIds = await loadBlockedUserIds(viewerId);
const blockedSet = new Set(blockedUserIds);
const filteredCandidateIds = candidateIds.filter(
  id => id !== viewerId && !blockedSet.has(id)
);
```

Removes:
- The requesting user (self)
- Users who have blocked the requester
- Users the requester has blocked

#### Step 5: Load Profile Data

```typescript
const profiles = await loadRecommendationProfiles(filteredCandidateIds, viewerId);
```

Loads profile information for candidates:
- Only visible, non-deleted profiles
- Includes display name, bio, location, age, gender, intent
- Includes avatar and hero media

#### Step 6: Build Response

```typescript
const responseProfiles = candidateIds
  .filter(id => profileMap.has(id))  // Only include profiles that exist
  .map(candidateId => {
    const profile = profileMap.get(candidateId)!;
    const scoreData = scoreByUserId.get(candidateId);
    
    // Build match reasons from score metadata
    const matchReasons: string[] = [];
    if (scoreData?.reasons) {
      // Extract reasons from score metadata
    }
    if (scoreData?.distanceKm) {
      matchReasons.push(`${distance} km away`);
    }
    
    return {
      userId: String(profile.userId),
      displayName: profile.displayName,
      // ... other profile fields
      matchReasons: matchReasons.length > 0 ? matchReasons : undefined
    };
  });
```

### Response Format

```typescript
{
  profiles: Array<{
    userId: string;
    displayName: string | null;
    bio: string | null;
    avatarUrl: string | null;
    heroUrl: string | null;
    locationText: string | null;
    age: number | null;
    gender: string;
    intent: string;
    matchReasons?: string[];  // e.g., ["Shared interests", "15 km away"]
  }>;
  nextCursor: string | null;  // Base64-encoded cursor for pagination
}
```

---

## Fallback Strategy (Future Enhancement)

### Current Limitation

If no match scores exist within the 7-day window, the API returns an empty array. This can happen if:
- The match score job hasn't run recently
- The user is new and hasn't been scored yet
- All scores are older than 7 days

### Proposed Fallback

Implement a tiered fallback system:

```typescript
// Try 7-day window first
let scored = await loadRecentMatchScores(viewerId, {
  limit: take,
  minAge: sevenDaysAgo
});

// Fallback 1: Expand to 30 days
if (scored.length === 0) {
  const thirtyDaysAgo = new Date();
  thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
  scored = await loadRecentMatchScores(viewerId, {
    limit: take,
    minAge: thirtyDaysAgo
  });
}

// Fallback 2: Remove time restriction (get any scores)
if (scored.length === 0) {
  scored = await loadRecentMatchScores(viewerId, {
    limit: take,
    minAge: undefined  // No time restriction
  });
}

// Fallback 3: Return lower-quality matches with warning
if (scored.length === 0) {
  // Could return profiles sorted by other criteria
  // (e.g., newest, closest, most active)
  // with a flag: { stale: true, quality: 'low' }
}
```

### Benefits of Fallback

1. **Better UX**: Users always see some recommendations
2. **Graceful Degradation**: System works even if job hasn't run
3. **Transparency**: Can flag stale/low-quality matches in UI

---

## Data Flow Diagram

```
┌─────────────────┐
│  matchScoreJob  │
│  (Background)   │
└────────┬────────┘
         │
         │ Computes scores
         │ Stores in DB
         ▼
┌─────────────────┐
│  MatchScore     │
│  Table          │
│  (scoredAt)     │
└────────┬────────┘
         │
         │ Query with 7-day filter
         ▼
┌─────────────────┐
│ loadRecentMatch │
│ Scores()        │
└────────┬────────┘
         │
         │ Filter: blocked, self
         ▼
┌─────────────────┐
│ loadRecommendation │
│ Profiles()      │
└────────┬────────┘
         │
         │ Build response
         ▼
┌─────────────────┐
│  API Response   │
│  {profiles, ...}│
└─────────────────┘
```

---

## Key Configuration

### Time Windows

- **Current**: 7 days (`sevenDaysAgo`)
- **Previous**: 1 day (too restrictive)
- **Recommended Fallback**: 30 days → unlimited

### Score Components

Match scores are computed from:
1. **Quiz Compatibility**: Trait matching from quiz answers
2. **Interests**: Shared interests and subjects
3. **Rating Quality**: Average ratings received
4. **Rating Fit**: Alignment with preferences
5. **Newness**: Recency bonus
6. **Proximity**: Geographic distance

### Filtering

Candidates are filtered out if:
- They are the requesting user (self)
- They have blocked the requesting user
- The requesting user has blocked them
- Their profile is deleted or not visible
- Their user account is deleted

---

## Troubleshooting

### No Recommendations Returned

**Symptoms**: API returns empty `profiles` array

**Possible Causes**:
1. Match score job hasn't run for this user
2. All scores are older than 7 days
3. All candidates are blocked
4. No profiles match visibility criteria

**Diagnosis**:
- Check backend logs for `[recommendations] Match scores loaded`
- Check `MatchScore` table: `SELECT COUNT(*) FROM MatchScore WHERE userId = ?`
- Check `scoredAt` timestamps: `SELECT MAX(scoredAt) FROM MatchScore WHERE userId = ?`

**Solutions**:
1. Run `matchScoreJob` for the user
2. Implement fallback strategy (expand time window)
3. Check blocking relationships
4. Verify profile visibility settings

---

## Related Files

- **Job**: `backend/src/jobs/matchScoreJob.ts`
- **Handler**: `backend/src/registry/domains/profiles/handlers/recommendations.ts`
- **Loaders**: `backend/src/registry/domains/profiles/loaders/recommendationsLoader.ts`
- **Schema**: `backend/prisma/schema/interests.prisma` (MatchScore model)
- **Frontend Hook**: `frontend/src/core/profile/search/useProfileSearch.ts`
- **Frontend API**: `frontend/src/api/client.ts` (`getRecommendations`)

---

## Future Improvements

1. **Implement Fallback Strategy**: Expand time window or remove restriction when no recent scores
2. **Real-time Scoring**: Score on-demand for new users instead of waiting for job
3. **Quality Indicators**: Flag stale/low-quality matches in response
4. **Caching**: Cache recommendations for frequently accessed users
5. **A/B Testing**: Test different time windows and scoring weights
